The registers available are 16 integer registers and 16 floating point registers. 
R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15 (Integer Registers)
F0,F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,F11,F12,F13,F14,F15. (Floating Point Registers)
The different opcodes are as follows.

MIN    
>> MIN R1 R2 R3 :: R1=MIN(R3,R2)
F_MIN
>> F_MIN F1 F2 F3 :: F1=MIN(F3,F2)
MAX
>> MAX  :: R1=MAX(R2,R3)
F_MAX
>> F_MAX F1 F2 F3 :: F1=MAX(R1,R2)
POWER
>> POWER R1 R2 R3 :: R1=R2^R3
F_POWER 
>> F_POWER F1 F2 F3 :: F1=F2^F3
ADD
>> ADD R1 R2 :: R1=R1+R2
F_ADD
>> F_ADD F1 F2 :: F1=F1+F2
SUB
>> SUB R1 R2 :: R1=R1-R2
F_SUB
>> F_SUB :: F1=F1-F2
MUL
>> MUL R1 R2 :: R1=R1*R2
F_MUL
>> F_MUL F1 F2 :: F1=F1*F2
DIV
>> DIV R1 R2 :: R1=R1/R2
F_DIV
>> F_DIV F1 F2 :: F1=F1*F2
SHIFTLI
>> SHIFTLI R1,DATA :: SHIFT LEFT R1 BY DATA BITS 
SHIFTRI
>> SHIFTRI R1,DATA :: SHIFT RIGHT R1 BY DATA BITS 
ROLLLD
>> ROLLLD R1,DATA :: ROTATE LEFT R1 BY DATA BITS SPECIFIED
ROLLRD
>> ROLLRD R1,DATA :: ROTATE RIGHT R1 BY DATA BITS SPECIFIED
MOV
>> MOV R1 R2 :: R1=R2 ( MOVE REGISTER VALUE OF R2 TO R1)
LOAD
>> LOAD R1 R2 :: R1=R2 ( LOAD VALUE STORED AT MEM ADDRESS SPECIFIED BY R2 TO R1)
F_LOAD
>> F_LOAD F1 F2 :: F1=F2 ( LOAD VALUE STORED AT MEM ADDRESS SPECIFIED BY R2 TO R1)
STORE
>>STORE R1 R2 :: R1=R2 ( STORE VALUE STORED AT MEM ADDRESS SPECIFIED BY R1 TO R2)
F_STORE
>>F_STORE F1 F2 :: F1=F2 ( STORE VALUE STORED AT MEM ADDRESS SPECIFIED BY F1 TO F2)
FACT
>> FACT R1 R2 :: R1= R2!
COMPARE
>> COMPARE R1 R2 :: if R1 = R2  return 0
	         :: if R1!=R2 return 1
F_COMPARE
>> COMPARE R1 R2 :: if F1=F2  return 0
	         :: if F1!=F2 return 1
AND
>> AND R1 R2 :: R1=R1 && R2
OR
>> OR R1 R2 :: R1=R1 && R2
XOR
>> XOR R1 R2 :: R1=R1 && R2
NOR
>> NOR R1 R2 :: R1=R1 && R2
NAND
>> NAND R1 R2 :: R1=R1 && R2
SUMC
>> SUM WITH CARRY 
F_SUMC
>> SUM WITH CARRY
SUBB
>> SUBTRACTION WITH BORROW
F_SUBB
>> SUBTRACTION WITH BORROW
F_MOV
>>MOV F1 F2 :: F1=F2 ( MOVE REGISTER VALUE OF F2 TO F1)
DEC
>> DEC R1 :: R1=R1-- 
INC
>> INC R1 :: R1=R1++
F_DEC
>> F_DEC F1 :: F1=F1-- 
F_INC
>> F_INC F1 :: F1=F1++
SHIFTL
>>SHIFTL R1 :: R1=R1*2
SHIFTR
>>SHIFTR R1 :: R1=R1/2
PUSH
>> PUSH R1 :: PUSH R1 TO THE STACK 
POP
>> POP R1 :: PUSH R1 FROM THE STACK
IN
>> IN PORT :: INPUT AT THIS PORT 
OUT
>> OUT PORT :: OUTPUT AT THIS PORT 
ROLLLC
>> ROLLLC R1 :: ROTATE LEFT WITH CARRY
ROLLRC
>> ROLLLC R1 :: ROTATE RIGHT WITH CARRY
STEP
>> STEP R1 :: JUMP TO THE MEMORY ADDRESS STORED BY R1 
STEPC
>> STEPC R1 :: JUMP TO THE MEMORY ADDRESS STORED BY R1 IF CARRY FLAG IS SET
STEPNC
>> STEPNC R1 :: JUMP TO THE MEMORY ADDRESS STORED BY R1 IF CARRY FLAG IS RESET
STEPP
>> STEPP R1 :: JUMP TO THE MEMORY ADDRESS STORED BY R1 IF PARITY FLAG IS SET
STEPM
>> STEPM R1 :: JUMP TO THE MEMORY ADDRESS STORED BY R1 IF MINUS FLAG IS SET
STEPZ
>> STEPZ R1 :: JUMP TO THE MEMORY ADDRESS STORED BY R1 IF ZERO FLAG IS SET
STEPNZ
>> STEPNZ R1 :: JUMP TO THE MEMORY ADDRESS STORED BY R1 IF ZERO FLAG IS RESET
STEPPE
>> STEPE R1 :: JUMP TO THE MEMORY ADDRESS STORED BY R1 IF EVEN PARITY
STEPPO
>> STEPO R1 :: JUMP TO THE MEMORY ADDRESS STORED BY R1 IF ODD PARITY
STEPL
>> STEPL R1 :: JUMP TO THE MEMORY ADDRESS STORED BY R1 IF LESS FLAG IS SET
STEPG
>> STEPG R1 :: JUMP TO THE MEMORY ADDRESS STORED BY R1 IF GREATER FLAG IS SET
STEPE
>> STEPE R1 :: JUMP TO THE MEMORY ADDRESS STORED BY R1 IF EQUAL FLAG IS SET
GO
>> GO :: GO R1 :: THE PROGRAM SEQUENCE IS TRANSFERRED TO THE MEMORY LOCATION SPECIFIED BY THE ADDRESS STORED IN R1 
GOC
>> GOC R1 :: GO IF CARRY
GONC
>> GONC R1 :: GO IF NOT CARRY
GOP
>> GOP R1 :: GO IF PARITY
GOM
>> GOM R1 :: GO IF MINUS
GOZ
>> GOZ R1 :: GO IF ZERO
GONZ
>> GONZ R1 :: GO IF NOT ZERO
GOPE
>> GOPE R1 :: GO IF EVEN PARITY
GOPO
>> GOPO R1 :: GO IF ODD PARITY
GOL
>> GOL R1 :: GO IF LARGE
GOG
>> GOG R1 :: GO IF GREATER
GOE
>> GOE R1 :: GO IF EQUAL
ROLLR
>> ROLL RIGHT
ROLLL
>> ROLL LEFT
CLC
>> CLEAR 
NOT
>> NOT THE CARRY FLAG
CLEAR
>> CLEAR
SETC
>> SET THE CARRY FLAG
RET
>> RETURN 
RETC
>> RETURN IF CARRY  
RETNC
>> RETURN IF NOT CARRY
RETP
>> RETURN IF PARITY 
RETM
>> RETURN IF MINUS
RETZ
>> RETURN IF ZERO
RETNZ
>> RETURN IF NOT ZERO
RETPE
>> RETURN IF EVEN PARITY
RETPO
>> RETURN IF ODD PARITY
RETL
>> RETURN IF LESS
RETG
>> RETURN IF GREATER
RETE
>> RETURN IF EQUAL
NOP
>> NO OPERATION
START
>> START THE PROGRAM
EI
>> ENABLE INTERUPT
DI
>> DISABLE INTERUPT
HLT
>> ENDS THE PROGRAM
